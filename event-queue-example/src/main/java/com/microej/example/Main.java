/*
 * Java
 *
 * Copyright 2023-2024 MicroEJ Corp. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be found with this software.
 */
package com.microej.example;

import java.nio.ByteOrder;
import java.util.Random;
import java.util.logging.Logger;

import ej.bon.ByteArray;
import ej.event.EventQueue;

/**
 * Generated by the build-firmware-singleapp-skeleton.<br>
 * Please keep it in sync with the property 'application.main.class' defined in module.ivy
 */
public class Main {

	private static final Logger LOGGER = Logger.getLogger("[Main] "); //$NON-NLS-1$

	private static final int WAITING_TIME_MS = 2000;

	private static final Random random = new Random();

	private static final int GPIO_ID_MASK = 0xFF;
	private static final int GPIO_ID_SHIFT = 16;
	private static final int GPIO_STATE_MASK = 0xFFFF;

	private static final int ACCELEROMETER_MAX_VALUE = 1000;
	private static final int ACCELEROMETER_ARRAY_DATA_SIZE = 12;
	private static final int ACCELEROMETER_ARRAY_Y_INDEX = 4;
	private static final int ACCELEROMETER_ARRAY_Z_INDEX = 8;

	private static final int WEATHER_ARRAY_DATA_SIZE = 17;
	private static final int WEATHER_MAX_VALUE = 100;
	private static final int WEATHER_WIND_INDEX = 8;
	private static final int WEATHER_RAIN_INDEX = 16;

	private static final int DOUBLE_ARRAY_SIZE = 8;
	private static final int FLOAT_ARRAY_SIZE = 4;

	private static final int DEFAULT_EVENT_MAX_VALUE = 100;
	private static final int DEFAULT_EXTENDED_EVENT_DATA_LENGTH = 10;

	private static final int SHIFT_8 = 8;
	private static final int SHIFT_16 = 16;
	private static final int SHIFT_24 = 24;
	private static final int SHIFT_32 = 32;
	private static final int SHIFT_40 = 40;
	private static final int SHIFT_48 = 48;
	private static final int SHIFT_56 = 56;

	/**
	 * Simple main.
	 *
	 * @param args
	 *            command line arguments.
	 * @throws InterruptedException
	 *             if {@link Thread#sleep(long)} throws {@link InterruptedException}.
	 */
	public static void main(String[] args) throws InterruptedException {
		// Get the instance and start the event queue.
		EventQueue eventQueue = EventQueue.getInstance();

		// Get a unique Id to register the GPIO listener.
		int gpioEventListenerType = eventQueue.getNewType();
		// Register the GPIO listener with the corresponding type.
		eventQueue.registerListener(new GPIOEventListener(), gpioEventListenerType);

		// Get a unique Id to register the Accelerometer listener.
		int accelerometerEventListenerType = eventQueue.getNewType();
		// Register the Accelerometer listener with the corresponding type.
		eventQueue.registerListener(new AccelerometerEventListener(), accelerometerEventListenerType);

		// Get a unique Id to register the Weather listener.
		int weatherEventListenerType = eventQueue.getNewType();
		// Register the Weather listener with the corresponding type.
		eventQueue.registerListener(new WeatherEventListener(), weatherEventListenerType);

		// Get an unregistered Id to test the default Listener.
		int notRegisteredType = eventQueue.getNewType();
		// Register the default listener.
		eventQueue.setDefaultListener(new DefaultListener());

		LOGGER.info("JAVA API"); //$NON-NLS-1$
		LOGGER.info("==========================="); //$NON-NLS-1$

		// Offer a basic event with the GPIO Id and the GPIO state.
		eventQueue.offerEvent(gpioEventListenerType, getGpioData());
		Thread.sleep(WAITING_TIME_MS);

		// Offer an extended event with the Accelerometer values.
		eventQueue.offerExtendedEvent(accelerometerEventListenerType, getAccelerometerData());
		Thread.sleep(WAITING_TIME_MS);

		// Offer an extended event with the Weather values.
		eventQueue.offerExtendedEvent(weatherEventListenerType, getWeatherData());
		Thread.sleep(WAITING_TIME_MS);

		// Offer basic and extended events to the queue with a type that is not registered by any listener.
		eventQueue.offerEvent(notRegisteredType, random.nextInt(DEFAULT_EVENT_MAX_VALUE));
		eventQueue.offerExtendedEvent(notRegisteredType, new byte[random.nextInt(DEFAULT_EXTENDED_EVENT_DATA_LENGTH)]);
		Thread.sleep(WAITING_TIME_MS);

		LOGGER.info("Native API"); //$NON-NLS-1$
		LOGGER.info("==========================="); //$NON-NLS-1$

		// Offer a basic event with the GPIO Id and the GPIO state through the Native API.
		EventQueueExampleNatives.offerGpioEvent(gpioEventListenerType);
		Thread.sleep(WAITING_TIME_MS);

		// Offer extended event with Accelerometer values through the Native API.
		EventQueueExampleNatives.offerAccelerometerEvent(accelerometerEventListenerType);
		Thread.sleep(WAITING_TIME_MS);

		// Offer extended event with Weather values through the Native API.
		EventQueueExampleNatives.offerWeatherEvent(weatherEventListenerType);
		Thread.sleep(WAITING_TIME_MS);

		// Offer basic and extended events to the queue with a type that is not registered by any listener through
		// the Native API.
		EventQueueExampleNatives.offerDefaultBasicEvent(notRegisteredType);
		EventQueueExampleNatives.offerDefaultExtendedEvent(notRegisteredType);
		Thread.sleep(WAITING_TIME_MS);

		System.exit(0);
	}

	/**
	 * The GPIO data are composed of the Id and the State of the GPIO:
	 *
	 * ID (8 bits) | STATE (16 bits)
	 *
	 * @return the randomized GPIO data.
	 */
	private static int getGpioData() {
		int gpioId = random.nextInt(GPIO_ID_MASK);
		int gpioState = random.nextInt(GPIO_STATE_MASK);

		LOGGER.info("GPIO data sent through the Queue: Id=" + gpioId + ", state=" + gpioState); //$NON-NLS-1$ //$NON-NLS-2$
		return ((gpioId & GPIO_ID_MASK) << GPIO_ID_SHIFT) | (gpioState & GPIO_STATE_MASK);
	}

	/**
	 * Accelerometer data are composed of three Integers corresponding to the X, Y and Z values of an accelerometer.
	 *
	 * @return the randomized accelerometer data.
	 */
	private static byte[] getAccelerometerData() {
		int x = random.nextInt(ACCELEROMETER_MAX_VALUE);
		int y = random.nextInt(ACCELEROMETER_MAX_VALUE);
		int z = random.nextInt(ACCELEROMETER_MAX_VALUE);

		LOGGER.info("Accelerometer data sent through the Queue: x = " + x + ", y=" + y + ", z=" + z); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$

		byte[] accelerometerData = new byte[ACCELEROMETER_ARRAY_DATA_SIZE];

		ByteArray.writeInt(accelerometerData, 0, x);
		ByteArray.writeInt(accelerometerData, ACCELEROMETER_ARRAY_Y_INDEX, y);
		ByteArray.writeInt(accelerometerData, ACCELEROMETER_ARRAY_Z_INDEX, z);

		return accelerometerData;
	}

	/**
	 * This listener is used to handle weather extended data received. The alignment of the data must be the same than
	 * the C structures.
	 *
	 * The weather extended data are composed of:
	 *
	 * - The temperature (float value). 4 bytes aligned, data[0:3].
	 *
	 * - The wind (double value). 8 bytes aligned, data[8:15].
	 *
	 * - The rain (boolean value). 1 byte aligned, data[16];
	 *
	 * @return the randomized weather data.
	 */
	private static byte[] getWeatherData() {
		float temperature = random.nextFloat() * WEATHER_MAX_VALUE;
		double wind = random.nextDouble() * WEATHER_MAX_VALUE;
		byte rain = (byte) random.nextInt(2);

		byte[] weatherValues = new byte[WEATHER_ARRAY_DATA_SIZE];

		// Get the array of bytes from the float value:
		byte[] floatArray = intToByteArray(Float.floatToIntBits(temperature));

		// Get the array of bytes from the double value:
		byte[] doubleArray = longToByteArray(Double.doubleToLongBits(wind));

		System.arraycopy(floatArray, 0, weatherValues, 0, FLOAT_ARRAY_SIZE);// 4 bytes aligned byte[0:4]
		System.arraycopy(doubleArray, 0, weatherValues, WEATHER_WIND_INDEX, DOUBLE_ARRAY_SIZE);// 8 bytes aligned ->
																								// byte[8:15]
		weatherValues[WEATHER_RAIN_INDEX] = rain;

		LOGGER.info("Weather data sent through the Queue: temperature = " + temperature + ", wind = " + wind //$NON-NLS-1$ //$NON-NLS-2$
				+ ", rain =" + rain); //$NON-NLS-1$

		return weatherValues;
	}

	/**
	 * Converts an integer value into a byte array depending on the endianness of the VEE Port.
	 *
	 * @param value
	 *            the integer value to convert.
	 * @return the byte array corresponding to the integer value.
	 */
	public static byte[] intToByteArray(int value) {
		byte[] returnInt;
		if (ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN)) {
			returnInt = new byte[] { (byte) (value), (byte) (value >> SHIFT_8), (byte) (value >> SHIFT_16),
					(byte) (value >> SHIFT_24) };
		} else {
			returnInt = new byte[] { (byte) (value >> SHIFT_24), (byte) (value >> SHIFT_16), (byte) (value >> SHIFT_8),
					(byte) (value) };
		}
		return returnInt;
	}

	/**
	 * Converts a long value into a byte array depending on the endianness of the VEE Port.
	 *
	 * @param value
	 *            the long value to convert.
	 * @return the byte array corresponding to the long value.
	 */
	public static byte[] longToByteArray(long value) {
		byte[] returnDouble;
		if (ByteOrder.nativeOrder().equals(ByteOrder.LITTLE_ENDIAN)) {
			returnDouble = new byte[] { (byte) (value), (byte) (value >> SHIFT_8), (byte) (value >> SHIFT_16),
					(byte) (value >> SHIFT_24), (byte) (value >> SHIFT_32), (byte) (value >> SHIFT_40),
					(byte) (value >> SHIFT_48), (byte) (value >> SHIFT_56) };
		} else {
			returnDouble = new byte[] { (byte) (value >> SHIFT_56), (byte) (value >> SHIFT_48),
					(byte) (value >> SHIFT_40), (byte) (value >> SHIFT_32), (byte) (value >> SHIFT_24),
					(byte) (value >> SHIFT_16), (byte) (value >> SHIFT_8), (byte) (value) };
		}
		return returnDouble;
	}
}
